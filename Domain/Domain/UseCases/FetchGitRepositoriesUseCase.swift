//
//  FetchGitRepositoriesUseCase.swift
//  Domain
//
//  Created by Victor C Tavernari on 02/04/20.
//  Copyright (c) 2020 Taverna Apps. All rights reserved.
//
//  This file was generated by BLU Clean
//

import Foundation

public enum CommonError: LocalizedError {
    case noInternetConnection
    case timeOut
    case generic(String)
}

public enum FetchGitRepositoriesError: LocalizedError {
    case common(CommonError)
    case termCannotBeEmpty
}

public protocol FetchGitRepositoriesUseCaseProtocol {
    func execute(term: String)
}

// sourcery: AutoMockable
public protocol FetchGitRepositoriesInterfaceAdapter {
    func doing()
    func done(data: [GitRepository])
    func failure(withError error: FetchGitRepositoriesError)
}

public class FetchGitRepositoriesUseCase: FetchGitRepositoriesUseCaseProtocol {
    public var delegateInterfaceAdapter: FetchGitRepositoriesInterfaceAdapter?
    private let gitRepoRepository: GitRepoRepositoryInterface
    private let reliabilityCalculatorUseCase: ReliabilityRepoCalculatorUseCase

    public init(
        gitRepoRepository: GitRepoRepositoryInterface,
        reliabilityCalculatorUseCase: ReliabilityRepoCalculatorUseCase
    ) {
        self.gitRepoRepository = gitRepoRepository
        self.reliabilityCalculatorUseCase = reliabilityCalculatorUseCase
    }

    private func handleError(_ error: Error) {
        if let error = error as? URLError {
            switch error.code {
            case URLError.Code.notConnectedToInternet:
                delegateInterfaceAdapter?.failure(withError: .common(.noInternetConnection))
            case URLError.Code.timedOut:
                delegateInterfaceAdapter?.failure(withError: .common(.timeOut))
            default:
                delegateInterfaceAdapter?.failure(withError: .common(.generic(error.localizedDescription)))
            }
        } else {
            delegateInterfaceAdapter?.failure(withError: .common(.generic(error.localizedDescription)))
        }
    }

    private func fetchRepositories(term: String, completion: @escaping ([GitRepository]) -> Void) {
        gitRepoRepository.list(term: term) { result in
            do {
                let repositories = try result.handle()
                completion(repositories)
            } catch { self.handleError(error) }
        }
    }

    private func fetchReliabilityConfig(completion: @escaping (GitRepoReliabilityMultiplier) -> Void) {
        gitRepoRepository.getRepoReliabilityMultiplier { result in
            do {
                let repoReliabilityMultiplierModel = try result.handle()
                completion(repoReliabilityMultiplierModel)
            } catch { self.handleError(error) }
        }
    }

    public func execute(term: String) {
        guard term.isEmpty == false else {
            delegateInterfaceAdapter?.failure(withError: FetchGitRepositoriesError.termCannotBeEmpty)
            return
        }

        delegateInterfaceAdapter?.doing()
        fetchRepositories(term: term) { repositories in
            self.fetchReliabilityConfig { repoReliabilityMultiplierModel in
                let repoResult = repositories.map { repo -> GitRepository in
                    var tempRepo = repo
                    let multiplier = repoReliabilityMultiplierModel.multiplier
                    let enable = repoReliabilityMultiplierModel.enable
                    tempRepo.isReliabilityEnabled = enable
                    let stats = repo.stats
                    tempRepo.reliabilityScore = self.reliabilityCalculatorUseCase.execute(repoStats: stats,
                                                                                          multiplier: multiplier)
                    return tempRepo
                }
                self.delegateInterfaceAdapter?.done(data: repoResult)
            }
        }
    }
}
