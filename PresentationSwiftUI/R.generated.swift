//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
    fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap(Locale.init) ?? Locale.current
    fileprivate static let hostingBundle = Bundle(for: R.Class.self)

    /// Find first language and bundle for which the table exists
    fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
        // Filter preferredLanguages to localizations, use first locale
        var languages = preferredLanguages
            .map(Locale.init)
            .prefix(1)
            .flatMap { locale -> [String] in
                if hostingBundle.localizations.contains(locale.identifier) {
                    if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
                        return [locale.identifier, language]
                    } else {
                        return [locale.identifier]
                    }
                } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
                    return [language]
                } else {
                    return []
                }
            }

        // If there's no languages, use development language as backstop
        if languages.isEmpty {
            if let developmentLocalization = hostingBundle.developmentLocalization {
                languages = [developmentLocalization]
            }
        } else {
            // Insert Base as second item (between locale identifier and languageCode)
            languages.insert("Base", at: 1)

            // Add development language as backstop
            if let developmentLocalization = hostingBundle.developmentLocalization {
                languages.append(developmentLocalization)
            }
        }

        // Find first language for which table exists
        // Note: key might not exist in chosen language (in that case, key will be shown)
        for language in languages {
            if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
                let lbundle = Bundle(url: lproj) {
                let strings = lbundle.url(forResource: tableName, withExtension: "strings")
                let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

                if strings != nil || stringsdict != nil {
                    return (Locale(identifier: language), lbundle)
                }
            }
        }

        // If table is available in main bundle, don't look for localized resources
        let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
        let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

        if strings != nil || stringsdict != nil {
            return (applicationLocale, hostingBundle)
        }

        // If table is not found for requested languages, key will be shown
        return nil
    }

    /// Load string from Info.plist file
    fileprivate static func infoPlistString(path: [String], key: String) -> String? {
        var dict = hostingBundle.infoDictionary
        for step in path {
            guard let obj = dict?[step] as? [String: Any] else { return nil }
            dict = obj
        }
        return dict?[key] as? String
    }

    static func validate() throws {
        try intern.validate()
    }

    #if os(iOS) || os(tvOS)
        /// This `R.storyboard` struct is generated, and contains static references to 1 storyboards.
        struct storyboard {
            /// Storyboard `LaunchScreen`.
            static let launchScreen = _R.storyboard.launchScreen()

            #if os(iOS) || os(tvOS)
                /// `UIStoryboard(name: "LaunchScreen", bundle: ...)`
                static func launchScreen(_: Void = ()) -> UIKit.UIStoryboard {
                    return UIKit.UIStoryboard(resource: R.storyboard.launchScreen)
                }
            #endif

            fileprivate init() {}
        }
    #endif

    /// This `R.color` struct is generated, and contains static references to 1 colors.
    struct color {
        /// Color `primary`.
        static let primary = Rswift.ColorResource(bundle: R.hostingBundle, name: "primary")

        #if os(iOS) || os(tvOS)
            /// `UIColor(named: "primary", bundle: ..., traitCollection: ...)`
            @available(tvOS 11.0, *)
            @available(iOS 11.0, *)
            static func primary(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
                return UIKit.UIColor(resource: R.color.primary, compatibleWith: traitCollection)
            }
        #endif

        fileprivate init() {}
    }

    /// This `R.file` struct is generated, and contains static references to 1 files.
    struct file {
        /// Resource file `GoogleService-Info.plist`.
        static let googleServiceInfoPlist = Rswift.FileResource(bundle: R.hostingBundle, name: "GoogleService-Info", pathExtension: "plist")

        /// `bundle.url(forResource: "GoogleService-Info", withExtension: "plist")`
        static func googleServiceInfoPlist(_: Void = ()) -> Foundation.URL? {
            let fileResource = R.file.googleServiceInfoPlist
            return fileResource.bundle.url(forResource: fileResource)
        }

        fileprivate init() {}
    }

    /// This `R.image` struct is generated, and contains static references to 2 images.
    struct image {
        /// Image `icn-acompanhar`.
        static let icnAcompanhar = Rswift.ImageResource(bundle: R.hostingBundle, name: "icn-acompanhar")
        /// Image `ozzy-avatar`.
        static let ozzyAvatar = Rswift.ImageResource(bundle: R.hostingBundle, name: "ozzy-avatar")

        #if os(iOS) || os(tvOS)
            /// `UIImage(named: "icn-acompanhar", bundle: ..., traitCollection: ...)`
            static func icnAcompanhar(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
                return UIKit.UIImage(resource: R.image.icnAcompanhar, compatibleWith: traitCollection)
            }
        #endif

        #if os(iOS) || os(tvOS)
            /// `UIImage(named: "ozzy-avatar", bundle: ..., traitCollection: ...)`
            static func ozzyAvatar(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
                return UIKit.UIImage(resource: R.image.ozzyAvatar, compatibleWith: traitCollection)
            }
        #endif

        fileprivate init() {}
    }

    /// This `R.string` struct is generated, and contains static references to 1 localization tables.
    struct string {
        /// This `R.string.localizable` struct is generated, and contains static references to 5 localization keys.
        struct localizable {
            /// en translation: Este repositório ainda não contém pull requests
            ///
            /// Locales: en
            static let pullRequestsListMessageEmpty = Rswift.StringResource(key: "pullRequestsList.message.empty", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
            /// en translation: Hello World
            ///
            /// Locales: en
            static let helloWorld = Rswift.StringResource(key: "Hello World", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
            /// en translation: Hello, %@
            ///
            /// Locales: en
            static let helloWithName = Rswift.StringResource(key: "Hello, %@.withName", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
            /// en translation: Não encontramos o cliente %@.
            ///
            /// Locales: en
            static let clientNotFound = Rswift.StringResource(key: "client.notFound", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
            /// en translation: Welcome, %@
            ///
            /// Locales: en
            static let welcomeWithName = Rswift.StringResource(key: "welcome.withName", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)

            /// en translation: Este repositório ainda não contém pull requests
            ///
            /// Locales: en
            static func pullRequestsListMessageEmpty(preferredLanguages: [String]? = nil) -> String {
                guard let preferredLanguages = preferredLanguages else {
                    return NSLocalizedString("pullRequestsList.message.empty", bundle: hostingBundle, comment: "")
                }

                guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
                    return "pullRequestsList.message.empty"
                }

                return NSLocalizedString("pullRequestsList.message.empty", bundle: bundle, comment: "")
            }

            /// en translation: Hello World
            ///
            /// Locales: en
            static func helloWorld(preferredLanguages: [String]? = nil) -> String {
                guard let preferredLanguages = preferredLanguages else {
                    return NSLocalizedString("Hello World", bundle: hostingBundle, comment: "")
                }

                guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
                    return "Hello World"
                }

                return NSLocalizedString("Hello World", bundle: bundle, comment: "")
            }

            /// en translation: Hello, %@
            ///
            /// Locales: en
            static func helloWithName(_ value1: String, preferredLanguages: [String]? = nil) -> String {
                guard let preferredLanguages = preferredLanguages else {
                    let format = NSLocalizedString("Hello, %@.withName", bundle: hostingBundle, comment: "")
                    return String(format: format, locale: applicationLocale, value1)
                }

                guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
                    return "Hello, %@.withName"
                }

                let format = NSLocalizedString("Hello, %@.withName", bundle: bundle, comment: "")
                return String(format: format, locale: locale, value1)
            }

            /// en translation: Não encontramos o cliente %@.
            ///
            /// Locales: en
            static func clientNotFound(_ value1: String, preferredLanguages: [String]? = nil) -> String {
                guard let preferredLanguages = preferredLanguages else {
                    let format = NSLocalizedString("client.notFound", bundle: hostingBundle, comment: "")
                    return String(format: format, locale: applicationLocale, value1)
                }

                guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
                    return "client.notFound"
                }

                let format = NSLocalizedString("client.notFound", bundle: bundle, comment: "")
                return String(format: format, locale: locale, value1)
            }

            /// en translation: Welcome, %@
            ///
            /// Locales: en
            static func welcomeWithName(_ value1: String, preferredLanguages: [String]? = nil) -> String {
                guard let preferredLanguages = preferredLanguages else {
                    let format = NSLocalizedString("welcome.withName", bundle: hostingBundle, comment: "")
                    return String(format: format, locale: applicationLocale, value1)
                }

                guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
                    return "welcome.withName"
                }

                let format = NSLocalizedString("welcome.withName", bundle: bundle, comment: "")
                return String(format: format, locale: locale, value1)
            }

            fileprivate init() {}
        }

        fileprivate init() {}
    }

    fileprivate struct intern: Rswift.Validatable {
        fileprivate static func validate() throws {
            try _R.validate()
        }

        fileprivate init() {}
    }

    fileprivate class Class {}

    fileprivate init() {}
}

struct _R: Rswift.Validatable {
    static func validate() throws {
        #if os(iOS) || os(tvOS)
            try storyboard.validate()
        #endif
    }

    #if os(iOS) || os(tvOS)
        struct storyboard: Rswift.Validatable {
            static func validate() throws {
                #if os(iOS) || os(tvOS)
                    try launchScreen.validate()
                #endif
            }

            #if os(iOS) || os(tvOS)
                struct launchScreen: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
                    typealias InitialController = UIKit.UIViewController

                    let bundle = R.hostingBundle
                    let name = "LaunchScreen"

                    static func validate() throws {
                        if #available(iOS 11.0, tvOS 11.0, *) {}
                    }

                    fileprivate init() {}
                }
            #endif

            fileprivate init() {}
        }
    #endif

    fileprivate init() {}
}
